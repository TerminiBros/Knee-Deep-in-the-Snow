#pragma once
#include <math.h>
#include <raylib.h>
#ifdef MAIN_IMPL
#include <reasings.h>
#define BATBOX_IMPL
#include "batbox.h"
#define BATANIM_IMPL
#include "batanim.h"
#define BATIO_IMPL
#include "batio.h"
#if defined(_DEBUG)
    #define TBDB_DEBUG_IMPL
    #include "tbdebug.h"
#endif
#endif
#if defined(PLATFORM_WEB)
    #include <emscripten/emscripten.h>
    #define GLSL_VERSION (100)
#else
    #define GLSL_VERSION (330)
#endif

//-----Globals-----//
#ifdef MVERSION
#define TITLE MTITLE        // Makefile definitions
#define VERSION MVERSION
#else
#define TITLE ("Template")  // Game title
#define VERSION ("2.2.2")   // Generated by makefile
#endif

#define NUM_SPRITES (512)

static bool showSplash = 1;
static int monitor = 0;
static int targetRefresh = 60;

static int initScale = 3;
static Rectangle content = {128, 128, 256, 256};
static float scaledWidth, scaledHeight;
static float oldScreenWidth, oldScreenHeight;
static Vector2 scaledOrigin, screenOrigin;

//-----Assets-----//
static RenderTexture2D rtxContent; // Pixel canvas
static RenderTexture2D rtxLightingTexture;
static RenderTexture2D rtxCombinedTexture;
static Texture2D texGrid;
static Texture2D texTestImage;
static Texture2D texPlane;
static Texture2D texSnowman;
static Texture2D texProps;
static Texture2D texSnowmanFaces;
static Texture2D texSky;
static Texture2D texLight0;
static Texture2D texWeapons;
static Texture2D texBullets;
static Shader shdWarp;
static Shader shdProp;
static Shader shdPropEm;
static Sound sfxPause;
static Font fntLilLabels;
#define LIL_LABELS_FONT_SIZE (7)

int LightmapUniformLoc;



// TODO: Baz set the color pool colors
static Color BulbColorPool[5] = {
    RED,
    GREEN, 
    YELLOW,
    BLUE,
    PINK
};

static Color BulbLightColorPool[5] = {
    RED,
    GREEN, 
    YELLOW,
    BLUE,
    PINK
};




//-----Definitions-----//
typedef struct State { // Global state, keeps track of time and mode
    int mode;
    int prevMode;
    double unpausedTime;
    double totalTime;
    double deltaTime;
    void (*UpdateFunc)(void);
    void (*DrawFunc)(void);
    bool isPaused;
    bool wasUnfocused;
} State;

enum Modes {
    MODE_SPLASH,
    MODE_GAME,
    MODE_PAUSED,
};

#ifdef MAIN_IMPL
State state;
#endif

//-----Functions-----//

 // Initializes window, target framerate, audio device, assets, splash screen
static void Init(void);
 // Runs once before update
static void Setup(void);
static void Update(void);
static void Draw(void);
static void Unload(void);
static void UpdateDrawFrame(void);

static void LoadAssets(void); 
static void UnloadAssets(void);

static void UpdateGame(void);
static void DrawGame(void);

static void PauseGame(void);
static void ResumeGame(void);
static void UpdatePaused(void);

static void ScaleWindowToContent(void);
static void DrawDebugInfo(void);

void SpawnPlayerBullet(int id, float x, float y, float h, Color c, Vector2 vel, int type);
void SpawnProp(int id, float x, float y, bool emissive, Rectangle prop, Vector2 scale);
void SpawnSnowman(int id, float x, float y);
void ClearAllSprites(void);
void ClearSprite(int i);
int FindFreeID(void);



#ifdef MAIN_IMPL
#include <raymath.h>

//-----Implementation-----//
void LoadAssets(void) { // Loads textures, shaders, audio, fonts, etc.
    rtxContent = LoadRenderTexture(content.width, content.height);
    rtxLightingTexture = LoadRenderTexture(256*4, 256*4);
    rtxCombinedTexture = LoadRenderTexture(256*4, 256*4);

    texTestImage = LoadTexture("assets/textures/test.png");
    texGrid = LoadTexture("assets/textures/grid.png");                              // Load a texture
    texPlane = LoadTexture("assets/textures/snow.png");
    texSnowman = LoadTexture("assets/textures/snowman.png");
    texSnowmanFaces = LoadTexture("assets/textures/snowman_faces.png");
    GenTextureMipmaps(&texPlane);
    texSky  = LoadTexture("assets/textures/skybox.png");
    texLight0 = LoadTexture("assets/textures/light0.png");
    SetTextureFilter(texLight0, TEXTURE_FILTER_BILINEAR);

    SetTextureWrap(rtxLightingTexture.texture, TEXTURE_WRAP_CLAMP);

    texWeapons = LoadTexture("assets/textures/weapons.png");
    texProps = LoadTexture("assets/textures/props.png");
    texBullets = LoadTexture("assets/textures/projectiles.png");

    shdWarp = LoadShader(0, TextFormat("assets/shaders/warp%d.fs", GLSL_VERSION));  // Load a shader based on GLSL version
    shdProp = LoadShader("assets/shaders/prop.vs", "assets/shaders/prop.fs");
    shdPropEm = LoadShader(0, "assets/shaders/prop.fs");
    LightmapUniformLoc = GetShaderLocation(shdProp, "texLightmap");

    sfxPause = LoadSound("assets/audio/pause.ogg");                                 // Load a sound
    fntLilLabels = LoadFontEx("assets/fonts/lil_labels.ttf", 7, 0, 0);              // Load a font
    SetTextureFilter(GetFontDefault().texture, TEXTURE_FILTER_POINT);               // Ensure default font is pixelated
}

void UnloadAssets(void) {
    UnloadRenderTexture(rtxContent);
}


enum GSType {
    GST_Prop,
    GST_Snowman,
    GST_EnemyBullet,
    GST_PlayerBullet
};

enum BulletType {
// player
    BTP_Melee,
    BTP_Bulb,
    BTP_Bulb2,
// enemy 
    BTE_Snowball,
    BTE_Explosion,
};

enum AI_Attack {
    AIA_snowball,
    AIA_snowball2,
    AIA_bomb,
};


enum AI_State {
    AIS_Wander,
    AIS_Hunt,
    AIS_Attack,
    AIS_Run,
};

typedef struct Light {
  float radius;
  Color color;  
} Light;

typedef struct AI {
    bool isAttacking;
    float attackCooldown;
    float stateCooldown;
    float extraCooldown;
    int state;
    int nextstate;
    float strafeSpeed;
    Vector2 velocity;
    bool stateCooldownEnabled;
//-
    float desiredDistance;
    float escapeDistance;
    float engageDistance;
    float wanderSpeed;
    float huntSpeed;
    float runSpeed;
    int attackType;
    bool friendly;
} AI;

typedef struct GameSprite {
    bool enabled;
    int type;
    int bulletType;
    bool baseIsEmissive;
    int emissiveFrames;
    float emissiveFrameSpeed;
    float x, y;
    float hover;
    float angle;
    uint16_t animID;
    bool isAnimated;
    Rectangle rect;
    Vector2 scale;
    Color c;
    bool hasLight;
    Light light;
    float size;
    int health;
    bool hasAI;
    AI ai;
} GameSprite;

#define Prop_Tree (Rectangle){0,0,64,64}
#define Prop_Bulb (Rectangle){64,0,64,64}

GameSprite sprites[NUM_SPRITES] = { 0
    //{.type = GST_Snowman, .x = 0, .y = 10, .c = RED, .enabled = true, .rect = {0,0,16,16}, .hasLight = true, .light = {.radius = 1.2, .color = RED}},
    //{.type = GST_Snowman, .x = 50, .y = 32, .c = PURPLE, .enabled = true, .rect = {0,0,16,16}, .hasLight = true, .light = {.radius = 1, .color = PINK}},
    //{.type = GST_Prop, .x = -40, .y = -14, .c = WHITE, .enabled = true, .rect = Prop_Tree, .scale = {4,4}},
    //{.type = GST_Prop, .x = -35, .y = -10, .c = WHITE, .enabled = true, .rect = Prop_Tree, .scale = {4,4}},
};

typedef struct Weapon {
// params
    bool specialAnimation;
    bool holdDown;
    int frames;
    float frameSpeed;
    int bulletType;
    float bulletSpeed;
    float cooldownMax;
    float animTimerMax;
    Rectangle spriteRect;
    Vector2 pivot;
    Vector2 offset;
    int ammoCap;
// runtime
    Color nextColor;
    float cooldown;
    float animTimer;
    float rotation;
    int ammo;
} Weapon;

static Vector2 playerPos = {0,0};
static Vector2 playerVel = {0,0};
static float rotationY = 0;
static float rotationX = 0;
static float skyScroll = 0; 
static int selectedWeapon = 0;

#define NUM_WEAPONS (2)
static Weapon weapons[NUM_WEAPONS] = {
    {   // CandyCane
        .bulletType = BTP_Melee,
        .bulletSpeed = 0,
        .ammo = -255,
        .ammoCap = -255,
        .frames = 0,
        .frameSpeed = 0,
        .cooldownMax = 0.5,
        .animTimerMax = 0.4,
        .specialAnimation = true,
        .holdDown = false,
        .offset = {64,100+40},
        .pivot = {64,100},
        .spriteRect = { 288, 0, 128, 160 },
        .nextColor = WHITE,
    },
    {   // BulbLauncher
        .bulletType = BTP_Bulb,
        .bulletSpeed = 22,
        .ammoCap = 6,
        .frames = 3,
        .frameSpeed = 3,
        .cooldownMax = 0.8,
        .animTimerMax = 0.7,
        .specialAnimation = false,
        .holdDown = false,
        .offset = {0,0},
        .pivot = {0,0},
        .spriteRect = { 0, 0, 96, 80 },
        .nextColor = WHITE,
    },
};

static int WeaponDamages[16] = {
    10,
    0,
    10,
};

static Rectangle PlayerBulletRects[16] = {
    {0,0,1,1},
    {0,0,24,24},
    {24,0,24,24},
};

bool isMouseLocked = false;
Vector2 mouseDelta = {0,0};
Vector2 mouseSensitivity = {40.1,20.05};
Vector2 moveSpeed = {10,10};

bool once = false;

void UpdateGame(void) {
    if (!once) {
        
        for (size_t i = 0; i < 128; i++)
        {
            SpawnProp(i, GetRandomValue(-128,128), GetRandomValue(-128,128), false, Prop_Tree, (Vector2){GetRandomValue(3,4),4} );
            if (GetRandomValue(0,5) == 0) {
                sprites[i].emissiveFrames = 2;
                sprites[i].emissiveFrameSpeed = 2;
            }
        }

        for (size_t i = 0; i < 10; i++)
        {
            SpawnSnowman(127 + i, GetRandomValue(-80, 80),GetRandomValue(-80, 80));
        }
        
        for (size_t i = 0; i < 15; i++)
        {
            SpawnProp(127 + 10 + i, GetRandomValue(-128,128), GetRandomValue(-128,128), true, Prop_Bulb, (Vector2){3,3} );
            sprites[127 + 10 + i].hasLight = true;
            int colorV = GetRandomValue(0,4);
            sprites[127 + 10 + i].c = BulbColorPool[colorV],
            sprites[127 + 10 + i].light = (Light){.color = BulbLightColorPool[colorV], .radius = 1.2f};
        }

        sprites[40].hasAI = true;
        sprites[40].emissiveFrames = 0;
        sprites[40].ai = (AI){
            .friendly = true, 
            .desiredDistance = 4, 
            .escapeDistance = 20, 
            .engageDistance = 9,
            .wanderSpeed = 4,
        };

        SpawnSnowman(300, 0, 10);
        sprites[300].hasAI = true;
        sprites[300].ai.state = AIS_Run;
        sprites[300].angle = 90;
        sprites[300].hasLight = true;
        sprites[300].light = (Light){.color = PURPLE, .radius = 2};
        
        once = true;
    }

    if (IsInputP(INPUT_START)) { PauseGame(); }

    if (!isMouseLocked) {
        if (IsMouseButtonDown(MOUSE_BUTTON_LEFT)) {
            isMouseLocked = true;
            DisableCursor();
        }
    } else {
        mouseDelta = GetMouseDelta();
        // SetMousePosition(content.x,content.y);

        if (IsKeyPressed(KEY_ESCAPE)) {
            isMouseLocked = false;
            mouseDelta = (Vector2) {0,0};
            EnableCursor();
        }
    }


    for (size_t i = 0; i < NUM_SPRITES; i++)
    {
        if (sprites[i].enabled == false) {continue;}

        if (sprites[i].health > -255 && sprites[i].health < 0) {
            sprites[i].enabled = false;
        }

        if (sprites[i].hasAI == true) {

            AI* ai = &sprites[i].ai;
            if (ai->friendly) {ai->state = AIS_Wander;}

            if (ai->stateCooldownEnabled && ai->stateCooldown <= 0) {
                ai->state = ai->nextstate;
                ai->stateCooldownEnabled = false;
            } else {
                ai->stateCooldown -= state.deltaTime;
            }

            switch (sprites[i].ai.state)
            {

            case AIS_Wander: {
                if (ai->extraCooldown <= 0) {
                    ai->extraCooldown = GetRandomValue(1,5) + (ai->friendly ? 2.3f : 0);

                    sprites[i].angle = GetRandomValue(0,360);
                    ai->velocity = Vector2Scale( Vector2Rotate((Vector2){0,1}, sprites[i].angle * DEG2RAD), ai->wanderSpeed );
                }
                ai->extraCooldown -= state.deltaTime;

                if (Vector2Distance((Vector2){sprites[i].x,sprites[i].y}, playerPos) < ai->engageDistance) {
                    ai->state = AIS_Hunt;
                }

                if (ai->stateCooldownEnabled == false) {
                    ai->stateCooldown = GetRandomValue(20,40);
                    ai->stateCooldownEnabled = true;
                    ai->nextstate = AIS_Hunt;
                }

                break;
            }

            case AIS_Run: {
                Vector2 diff = Vector2Subtract((Vector2){sprites[i].x,sprites[i].y}, playerPos);
                Vector2 normdiff = Vector2Normalize(diff);
                ai->velocity = Vector2Scale( Vector2Normalize(diff), ai->runSpeed );
                sprites[i].angle = RAD2DEG * (-atan2f(normdiff.y, normdiff.x)) + 180 + 90;
                //sprites[i].angle = RAD2DEG * (180 + atan2f(ai->velocity.x, ai->velocity.y));

                if (Vector2Distance((Vector2){sprites[i].x,sprites[i].y}, playerPos) > ai->escapeDistance) {
                    ai->state = AIS_Wander;
                }

                if (!ai->stateCooldownEnabled) {ai->stateCooldown = 8.0; ai->nextstate = AIS_Attack; ai->stateCooldownEnabled = true;}
                break;
            }

            case AIS_Hunt: {
                Vector2 diff = Vector2Subtract(playerPos, (Vector2){sprites[i].x,sprites[i].y});
                Vector2 normdiff = Vector2Normalize(diff);
                sprites[i].angle = RAD2DEG * (-atan2f(normdiff.y, normdiff.x)) + 180 + 90;

                ai->velocity = Vector2Scale( Vector2Normalize(diff), ai->huntSpeed );
                //sprites[i].angle = (RAD2DEG * (atan2f(ai->velocity.x, ai->velocity.y)));
                
                if (Vector2Distance(playerPos, (Vector2){sprites[i].x,sprites[i].y}) < ai->desiredDistance) {
                    ai->state = AIS_Attack;
                }

                break;
            }

            case AIS_Attack: {
                Vector2 diff = Vector2Subtract(playerPos, (Vector2){sprites[i].x,sprites[i].y});
                Vector2 normdiff = Vector2Normalize(diff);
                Vector2 rightDiff = Vector2Rotate(normdiff,90*DEG2RAD);
                if (Vector2Distance(playerPos, (Vector2){sprites[i].x,sprites[i].y}) > ai->desiredDistance + 2) {
                    ai->velocity = Vector2Scale( Vector2Normalize(diff), ai->huntSpeed + 1);
                    ai->velocity = Vector2Add(ai->velocity, Vector2Scale(rightDiff,ai->strafeSpeed));
                
                } else if (Vector2Distance(playerPos, (Vector2){sprites[i].x,sprites[i].y}) < ai->desiredDistance - 2) {
                    ai->velocity = Vector2Scale( Vector2Normalize(diff), -ai->huntSpeed + 1);
                    ai->velocity = Vector2Add(ai->velocity, Vector2Scale(rightDiff,ai->strafeSpeed));
                } else {
                    ai->velocity = Vector2Lerp(ai->velocity, Vector2Zero(), state.deltaTime * 10);
                }
                ai->velocity = Vector2Add(ai->velocity, Vector2Scale(rightDiff,ai->strafeSpeed));
                sprites[i].angle = RAD2DEG * (-atan2f(normdiff.y, normdiff.x)) + 180 + 90;
                
                break;
            }

            default:
                TraceLog(LOG_ERROR, "Sprite with ID [%d] has unknown AI state: [%d]. This sprite will be deleted.", i, sprites[i].ai.state);
                sprites[i] = (GameSprite){0};
                break;
            }

            sprites[i].x += sprites[i].ai.velocity.x * state.deltaTime;
            sprites[i].y += sprites[i].ai.velocity.y * state.deltaTime;
            
            sprites[i].x = Clamp(sprites[i].x, -100, 100);
            sprites[i].y = Clamp(sprites[i].y, -100, 100);

        }


        if (sprites[i].type == GST_PlayerBullet || sprites[i].type == GST_EnemyBullet) {
            sprites[i].x += sprites[i].ai.velocity.x * state.deltaTime;
            sprites[i].y += sprites[i].ai.velocity.y * state.deltaTime;
            sprites[i].hover -= state.deltaTime;

            bool markForDeath = false;

            for (size_t ei = 0; ei < NUM_SPRITES; ei++)
            {
                if (sprites[ei].enabled && sprites[ei].type == GST_Snowman) {
                    if (CheckCollisionCircles(
                        (Vector2){sprites[i].x, sprites[i].y}, sprites[i].size,
                        (Vector2){sprites[ei].x, sprites[ei].y}, sprites[ei].size
                    )) {
                        sprites[ei].health -= WeaponDamages[sprites[i].bulletType];
                        markForDeath = true;
                    }
                }
            }
            
            if (sprites[i].hover <= 0) {
                markForDeath = true;
            }

            if (markForDeath) {
                // TODO: Do extra fancy stuff per bullet type here!

                if (sprites[i].bulletType == BTP_Bulb) {
                    for (size_t ei = 0; ei < NUM_SPRITES; ei++)
                    {
                        if (sprites[ei].enabled && sprites[ei].type == GST_Snowman) {
                            if (Vector2Distance((Vector2){sprites[i].x, sprites[i].y}, (Vector2){sprites[ei].x, sprites[ei].y}) < 3.0) {
                                sprites[ei].health -= WeaponDamages[BTP_Bulb2];
                            }
                        }
                    }       
                }

                sprites[i] = (GameSprite){0};
            }
        }

    }


    /// $PLAYER CODE

    if (isMouseLocked) {

        if (IsKeyPressed(KEY_ONE)) {
            selectedWeapon = 0;
        }

        if (IsKeyPressed(KEY_TWO)) {
            selectedWeapon = 1;
        }

        if ( weapons[selectedWeapon].cooldown <= 0) {
            if ((weapons[selectedWeapon].holdDown == false && IsMouseButtonPressed(MOUSE_BUTTON_LEFT))
            ||  (weapons[selectedWeapon].holdDown == true  && IsMouseButtonDown(MOUSE_BUTTON_LEFT))
            ) {
                weapons[selectedWeapon].cooldown = weapons[selectedWeapon].cooldownMax;
                weapons[selectedWeapon].animTimer = weapons[selectedWeapon].animTimerMax;


                Vector2 vdir = Vector2Rotate((Vector2){0,1}, DEG2RAD * -rotationY);
                Vector2 forward = Vector2Add( playerPos, vdir );

                SpawnPlayerBullet(FindFreeID(), forward.x, forward.y, 1.0, weapons[selectedWeapon].nextColor, Vector2Scale(vdir,weapons[selectedWeapon].bulletSpeed), weapons[selectedWeapon].bulletType);
                if (selectedWeapon == 1) {
                    weapons[selectedWeapon].nextColor = BulbColorPool[GetRandomValue(0,5)];
                }
            }
        }

    }

    for (size_t i = 0; i < NUM_WEAPONS; i++)
    {
        weapons[i].cooldown -= state.deltaTime;
        weapons[i].animTimer -= state.deltaTime;
        weapons[i].animTimer = Clamp(weapons[i].animTimer, 0, weapons[i].animTimerMax);
    }
    

    DebugDrawInt(10, 240, "WEAP", selectedWeapon);


    rotationY -= mouseDelta.x * mouseSensitivity.x * state.deltaTime;
    if (rotationY > 360) rotationY -= 360;
    if (rotationY < 0) rotationY += 360;
    rotationX += mouseDelta.y * mouseSensitivity.y * state.deltaTime;
    rotationX = Clamp(rotationX,-80,70);

    skyScroll -= mouseDelta.x * mouseSensitivity.x * state.deltaTime;
    if (skyScroll > 360*2) skyScroll -= 360*2;
    if (skyScroll < 0) skyScroll += 360*2;

    int horizontal = (( (input & INPUT_RIGHT) > 0) - ((input & INPUT_LEFT) > 0 ));
    int vertical   = (( (input & INPUT_DOWN) > 0) - ((input & INPUT_UP) > 0 ));
    
    Vector2 playerInput = Vector2Normalize((Vector2){-horizontal, -vertical});

    playerVel =  Vector2Lerp( playerVel, (Vector2){playerInput.x * moveSpeed.x, playerInput.y * moveSpeed.y}, state.deltaTime * 15);

    playerPos = Vector2Add(Vector2Rotate((Vector2){playerVel.x * state.deltaTime, playerVel.y * state.deltaTime }, (-rotationY) * DEG2RAD),playerPos); 

    playerPos = Vector2Clamp(playerPos, (Vector2){-100,-100}, (Vector2){100,100});
    
}

void ClearSprite(int id) {
    sprites[id] = (GameSprite){0};
}

void ClearAllSprites(void) {
    for (size_t i = 0; i < NUM_SPRITES; i++)
    {
        sprites[i] = (GameSprite){0};
    }
}

int FindFreeID(void) {
    for (size_t i = 0; i < NUM_SPRITES; i++)
    {
        if (!sprites[i].enabled) {return i;}
    } 
    return -1;   
}

void SpawnPlayerBullet(int id, float x, float y, float h, Color c, Vector2 vel, int type) {
    if (!sprites[id].enabled) {
        sprites[id] = (GameSprite){
            .enabled = true,
            .type = GST_PlayerBullet, 
            .x = x, 
            .y = y, 
            .c = c, 
            .rect = PlayerBulletRects[type], 
            .hover = h,
            .size = .6,
            .ai.velocity = vel,
            .bulletType = type,
        };
        if (type == BTP_Bulb) {
            sprites[id].hasLight = true;
            sprites[id].light = (Light){.radius = .4, .color = c};
        }
    }
}

void SpawnProp(int id, float x, float y, bool emissive, Rectangle prop, Vector2 scale) {
    if (!sprites[id].enabled) {
        sprites[id] = (GameSprite){
            .enabled = true,
            .type = GST_Prop, 
            .x = x, 
            .y = y, 
            .c = WHITE, 
            .rect = prop, 
            .scale = scale,
            .health = -255,
            .hover = 0,
            .baseIsEmissive = emissive,
            .emissiveFrames = emissive ? 1 : 0,
            .emissiveFrameSpeed = emissive ? 1 : 0,
            .size = 2
        };
    }
}

void SpawnSnowman(int id, float x, float y) {
    if (!sprites[id].enabled) {

        sprites[id] = (GameSprite){
            .enabled = true,
            .type = GST_Snowman, 
            .x = x, 
            .y = y, 
            .c = RED,
            .size = 1,
            .hasLight = true,
            .health = 20,
            // /.light = {.radius = 0.4, .color = LIGHTGRAY},
            .hasAI = true,
            .ai = {
                .friendly =false,
                .wanderSpeed = 5,
                .runSpeed = 6.8,
                .huntSpeed = 5.5,
                .desiredDistance = 5 + ((float)GetRandomValue(-20,20) / 10.0), 
                .escapeDistance = 33, 
                .engageDistance = 9, 
                .attackType = AIA_snowball,
                .strafeSpeed = (float)GetRandomValue(1, 4) / 10.0,//((float)GetRandomValue(1, 4) / 1000.0) * GetRandomValue(0,1) == 0 ? -1 : 1, 
            },
        };
        
        return;
    }
}

void DrawSnowman(Camera cam, int spriteIndex) {
    int i = spriteIndex;

    Rectangle r0 = (Rectangle){0,48,64,48};
    Rectangle r0b = (Rectangle){0,48+48,64,48};
    Rectangle r1 = (Rectangle){64,0,64,48};
    Rectangle r1b = (Rectangle){64,48,64,48};
    Rectangle r2 = (Rectangle){0,0,48,48};
    
    //Rectangle fr0 = (Rectangle){0,0,48,48};

    Rectangle faces[4] = {
        (Rectangle){0,0,48,48},
        (Rectangle){48*3,0,48,48},
        (Rectangle){48*2,0,1,1},
        (Rectangle){48,0,48,48},
    };

    float bob0 = 0.03 * sin(state.unpausedTime * 4);
    float bob1 = 0.02 * sin(state.unpausedTime * 3.8);
    float bob2 = 0.01 * sin(state.unpausedTime * 3.5);




    int faceToDraw = 0; //(int)state.unpausedTime % 4;

    Vector2 positionToCameraDifference = Vector2Subtract( (playerPos) , (Vector2){sprites[i].x,sprites[i].y} );
    
    Vector2 directionOffsetVector = Vector2Rotate((Vector2){0,1}, sprites[i].angle);

    const float sliceAngle = 360 / 4;

    //float directionOffsetAngle = RAD2DEG * atan2f(directionOffsetVector.x, directionOffsetVector.y);


    float angleToCamera = 180 + RAD2DEG * atan2f(positionToCameraDifference.x, positionToCameraDifference.y);
    angleToCamera += 360 - sprites[i].angle + 45; //directionOffsetAngle;
    angleToCamera = (int)angleToCamera % 360;

    int indexIntoSprites = (int)floorf(angleToCamera / sliceAngle);

    faceToDraw = indexIntoSprites;


    DrawBillboardRec(cam, texSnowman, r0, (Vector3){ sprites[i].x, 0.5 + bob0, sprites[i].y }, (Vector2){1,1}, WHITE);

    Vector2 pos = Vector2MoveTowards((Vector2){sprites[i].x, sprites[i].y}, playerPos, 0.1f);

    if (faceToDraw == 0)
        DrawBillboardRec(cam, texSnowman, r0b, (Vector3){ pos.x, 0.5 + bob0, pos.y }, (Vector2){1,1}, WHITE);

    DrawBillboardRec(cam, texSnowman, r1, (Vector3){ pos.x, 1.1 + bob0 + bob1, pos.y }, (Vector2){1,1}, WHITE);

    pos = Vector2MoveTowards(pos, playerPos, 0.1f);
    
    if (faceToDraw == 0)
        DrawBillboardRec(cam, texSnowman, r1b, (Vector3){ pos.x, 1.1 + bob0 + bob1, pos.y }, (Vector2){1,1}, WHITE);
    
    DrawBillboardRec(cam, texSnowman, r2, (Vector3){ pos.x, 1.6 + bob0 + bob1 + bob2, pos.y }, (Vector2){1,1}, WHITE);

    pos = Vector2MoveTowards(pos, playerPos, 0.1f);
    
    DrawBillboardRec(cam, texSnowmanFaces, faces[faceToDraw], (Vector3){ pos.x, 1.6 + bob0 + bob1 + bob2, pos.y }, (Vector2){1,1}, WHITE);


}



Vector2 MapCoordToLightCoord(float x, float y) {
    return (Vector2){(x+128) * 4, (y+128) * 4};
}


void RenderLightingTexture(void) {
    BeginTextureMode(rtxLightingTexture); {

        DrawRectangle(0,0,256*4,256*4, GetColor(0x01021aFF));
        Vector2 pl = MapCoordToLightCoord(playerPos.x,playerPos.y);

        DrawTextureEx(texLight0, Vector2Subtract((Vector2){pl.x, pl.y} , (Vector2){16*20,16*20}), 0, 20, GetColor(0x22223222));

        float scale = 5.3;
        float colorscale = scale * 1.2;
        DrawTextureEx(texLight0, Vector2Subtract((Vector2){pl.x, pl.y} , (Vector2){16*scale,16*scale}), 0, scale, GetColor(0x99999944));
        
        for (size_t i = 0; i < NUM_SPRITES; i++)
        {
            if (!sprites[i].enabled || !sprites[i].hasLight) continue;

            Vector2 p = MapCoordToLightCoord(sprites[i].x, sprites[i].y);
            float s   = sprites[i].light.radius;

            DrawTextureEx(texLight0, Vector2Subtract((Vector2){p.x, p.y} , (Vector2){16*s,16*s}), 0, s, GetColor(0xAAAAAA77));
        }
        

        BeginBlendMode(BLEND_ADDITIVE);
        for (size_t i = 0; i < NUM_SPRITES; i++)
        {
            if (!sprites[i].enabled || !sprites[i].hasLight) continue;

            Vector2 p = MapCoordToLightCoord(sprites[i].x, sprites[i].y);
            float s   = sprites[i].light.radius * 1.2;

            DrawTextureEx(texLight0, Vector2Subtract((Vector2){p.x, p.y} , (Vector2){16*s,16*s}), 0, s, sprites[i].light.color);
        }
        DrawTextureEx(texLight0, Vector2Subtract((Vector2){pl.x, pl.y} , (Vector2){16*colorscale,16*colorscale}), 0, colorscale, GetColor(0xAAAAAAAA) );
        EndBlendMode();
        
        //DrawTextureEx(texTestImage, (Vector2){0,0}, 0, 4, WHITE);

        EndTextureMode();
    }

    BeginTextureMode(rtxCombinedTexture); {

        DrawTextureTiled(texPlane, (Rectangle) {0, 0, 512, 512}, (Rectangle) {0, 0, 1024, 1024}, (Vector2) {0, 0}, 0, 1, WHITE);

        BeginBlendMode(BLEND_MULTIPLIED);
        DrawTextureQuad(rtxLightingTexture.texture, (Vector2){1,-1}, (Vector2){0,0}, (Rectangle){0,0,256*4,256*4}, WHITE);
        EndBlendMode();

        EndTextureMode();
    } 


}

void RenderScene(void) {

    DrawTextureRec(texSky, (Rectangle) {0, 0, 360, 256},    (Vector2) {skyScroll, 0}, WHITE);
    DrawTextureRec(texSky, (Rectangle) {0, 0, 360, 256},    (Vector2) {skyScroll - 360, 0}, WHITE);
    DrawTextureRec(texSky, (Rectangle) {0, 256, 360, 256},  (Vector2) {skyScroll - 360 * 2, 0}, WHITE);


    Camera cam;
    cam.projection = CAMERA_PERSPECTIVE;
    cam.fovy = 90;

    cam.up = (Vector3){0,1,0};

    float bobbing = sin(state.unpausedTime * 12) * Vector2Length( (Vector2) {playerVel.x / moveSpeed.x, playerVel.y / moveSpeed.y} ) * 0.06;

    cam.position = (Vector3){playerPos.x, 1 +  bobbing,playerPos.y};


    Quaternion Q = QuaternionMultiply(
        QuaternionFromAxisAngle((Vector3){0,1,0}, rotationY * DEG2RAD),
        QuaternionFromAxisAngle((Vector3){1,0,0}, rotationX * DEG2RAD)
    );

    cam.target = Vector3Add(
        cam.position,
        Vector3RotateByQuaternion((Vector3){0,0,1}, Q)
    );

    BeginMode3D(cam);


    DrawCubeTexture(rtxCombinedTexture.texture, (Vector3){0,0,0}, 256, 0.1, 256, WHITE);

    SetShaderValueTexture(shdProp, LightmapUniformLoc, rtxLightingTexture.texture);
    BeginShaderMode(shdProp);

    for (size_t i = 0; i < NUM_SPRITES; i++)
    {
        if (sprites[i].enabled == false) {continue;}
        
        switch (sprites[i].type)
        {

        case GST_Prop: {
            if (sprites[i].baseIsEmissive) {break;}
            DrawBillboardRec(cam, texProps, sprites[i].rect, (Vector3){ sprites[i].x, sprites[i].scale.y / 2, sprites[i].y }, sprites[i].scale, sprites[i].c);
            break;
        }

        case GST_PlayerBullet: {
            DrawBillboardRec(cam, texBullets, sprites[i].rect, (Vector3){ sprites[i].x, sprites[i].scale.y / 2 + sprites[i].hover, sprites[i].y }, (Vector2){1,1}, sprites[i].c);
            break;
        }

        case GST_EnemyBullet: {
            DrawBillboardRec(cam, texBullets, sprites[i].rect, (Vector3){ sprites[i].x, sprites[i].scale.y / 2 + sprites[i].hover, sprites[i].y }, (Vector2){1,1}, sprites[i].c);
            break;
        }
        
        case GST_Snowman: {
            DrawSnowman(cam, i);
            break;
        }
            
        default:
            break;
        }
        
    }

    EndShaderMode();

    // draw emissive 
    BeginShaderMode(shdPropEm);

    BeginBlendMode(BLEND_ALPHA);

    for (size_t i = 0; i < NUM_SPRITES; i++)
    {
        if (sprites[i].enabled == false) {continue;}
        
        
        Vector2 pos = (Vector2){sprites[i].x, sprites[i].y};
        if (sprites[i].baseIsEmissive) {
            DrawBillboardRec(cam, texProps, 
                (Rectangle) {sprites[i].rect.x, sprites[i].rect.y, sprites[i].rect.width, sprites[i].rect.height }, 
                (Vector3){ pos.x, sprites[i].scale.y / 2 + sprites[i].hover, pos.y }, sprites[i].scale, sprites[i].c
            );
        }
        
        if (sprites[i].emissiveFrames > 0) {

            if (Vector2Distance(pos, playerPos) > 50) {continue;}

            pos = Vector2MoveTowards(pos, playerPos, 0.025f);
            int frame = 1 + (int)(state.unpausedTime * sprites[i].emissiveFrameSpeed) % sprites[i].emissiveFrames;
            DrawBillboardRec(cam, texProps, 
                (Rectangle) {sprites[i].rect.x, sprites[i].rect.y + (64 * frame) , sprites[i].rect.width, sprites[i].rect.height }, 
                (Vector3){ pos.x, sprites[i].scale.y / 2 + sprites[i].hover, pos.y }, sprites[i].scale, WHITE
            );
        }
    }

    EndBlendMode();

    EndShaderMode();    

    EndMode3D();

    

}

void RenderMapOverlay(void) {
    float ox = 128;
    float oy = 128;


    //DrawTextureEx(rtxLightingTexture.texture, (Vector2){0,0}, 0, 0.25, WHITE);
    if (IsKeyDown(KEY_LEFT_SHIFT)) {
        DrawTextureQuad(rtxLightingTexture.texture, (Vector2){1,-1}, (Vector2){0,0}, (Rectangle){0,0,256,256}, WHITE);
    }

    DrawPixel(ox + playerPos.x,oy + playerPos.y, GREEN);
    Vector2 lookLine = Vector2Add(Vector2Rotate((Vector2){0, 8}, (-rotationY) * DEG2RAD), playerPos);
    DrawLine( ox + playerPos.x, oy + playerPos.y, ox + lookLine.x, oy + lookLine.y, GREEN);

    Vector2 lookLine1 = Vector2Add(Vector2Rotate((Vector2){0, 13}, (-rotationY-45) * DEG2RAD), playerPos);
    DrawLine( ox + playerPos.x, oy + playerPos.y, ox + lookLine1.x, oy + lookLine1.y, BLUE);
    Vector2 lookLine2 = Vector2Add(Vector2Rotate((Vector2){0, 13}, (-rotationY+45) * DEG2RAD), playerPos);
    DrawLine( ox + playerPos.x, oy + playerPos.y, ox + lookLine2.x, oy + lookLine2.y, BLUE);

    for (size_t i = 0; i < NUM_SPRITES; i++)
    {
        if (!sprites[i].enabled) continue;
        DrawPixel(ox + sprites[i].x, oy + sprites[i].y, sprites[i].c);
        //if (sprites[i].hasAI) {
            Vector2 lookLine = Vector2Add(Vector2Rotate((Vector2){0, 4}, (sprites[i].angle) * DEG2RAD), (Vector2){sprites[i].x, sprites[i].y});
            DrawLine( ox + sprites[i].x, oy + sprites[i].y, ox + lookLine.x, oy + lookLine.y, ORANGE);
        //}
    }

}

void DrawWeapons(void) {

    if (weapons[selectedWeapon].cooldown > 0) {
        DrawTexture(texLight0, 20, 20, RED);
    }

    float recoil = Lerp(0, 10, weapons[selectedWeapon].animTimer / weapons[selectedWeapon].animTimerMax);
    float altRot = 0;
    if (weapons[selectedWeapon].specialAnimation) {
        recoil *= -4;
        altRot = Lerp(0,-10, weapons[selectedWeapon].animTimer / weapons[selectedWeapon].animTimerMax);
    }

    DrawTexturePro(
        texWeapons,
        weapons[selectedWeapon].spriteRect,
        (Rectangle) { 
            128 - weapons[selectedWeapon].spriteRect.width/2 + weapons[selectedWeapon].offset.x, 
            256 - weapons[selectedWeapon].spriteRect.height + weapons[selectedWeapon].offset.y + recoil,
            weapons[selectedWeapon].spriteRect.width,
            weapons[selectedWeapon].spriteRect.height
        },
        weapons[selectedWeapon].pivot, weapons[selectedWeapon].rotation + altRot,
        WHITE
    );
}

void DrawGame(void) {
    ClearBackground(RAYWHITE);

    //for (int j = 0; j < content.height / 16; j++) { for (int i = 0; i < content.width / 16; i++) DrawTexture(texGrid, i * 16, j * 16, Fade(LIGHTGRAY, 0.4)); }
    
    RenderScene();

    DrawWeapons();

    if (IsKeyDown(KEY_TAB)) {
        RenderMapOverlay();
    }

    DrawText(TextFormat("%s v%s", TITLE, VERSION), 3, 2, 10, DARKGRAY);

    static double fadeTimer = 0.4;
    if (fadeTimer > 0) { DrawRectangle(0, 0, content.width, content.height, Fade(BLACK, EaseQuadOut(fadeTimer, 0, 1, 0.4))); fadeTimer -= state.deltaTime; }
}

void PauseGame(void) {
    state.isPaused = true;
    state.prevMode = state.mode;
    state.mode = MODE_PAUSED;
    if (state.wasUnfocused) { return; }
    PlaySoundPitch(sfxPause, 1.0, false);
}

void ResumeGame(void) {
    state.isPaused = false;
    state.mode = state.prevMode;
    if (state.wasUnfocused) { return; }
    PlaySoundPitch(sfxPause, 1.1, false);
}

void UpdatePaused(void) {
    if (IsInputP(INPUT_START)) { ResumeGame(); }
}

void DrawPausedOverlay(void) {
    if (!state.isPaused) { return; }
    DrawRectangle(0, 0, content.width, content.height, Fade(BLACK, 0.5));
    if (state.wasUnfocused) { return; }
    DrawTextCentered("PAUSED", content.x, content.y, 10, 1, WHITE);
}

void DrawContent(void) {
    DrawTexturePro(rtxContent.texture,
    (Rectangle) {0, 0, content.width, -content.height},
    (Rectangle) {0, 0, content.width, content.height},
    (Vector2) {0, 0}, 0, WHITE);

    state.DrawFunc();

    DrawDebugInfo();
    
    DrawPausedOverlay();
}

void DrawDebugInfo(void) {
#if defined(_DEBUG)
    #define MAX_FRAME_SAMPLES (100)
    static float frameSamples[MAX_FRAME_SAMPLES] = {0};
    static float frameSampleTimer = 0;

    frameSampleTimer -= state.deltaTime;
    if (frameSampleTimer <= 0) {
        for (int i = MAX_FRAME_SAMPLES - 1; i > 0; i--) { frameSamples[i] = frameSamples[i-1]; }
        frameSamples[0] = GetFrameTime();
        frameSampleTimer = (1 / 60) * 10; 
    }
    for (int i = 0; i < MAX_FRAME_SAMPLES; i++) {
        float delayTime = frameSamples[i];
        for (int j = 0; j < delayTime * 50; j++) {
            DrawPixel(content.width - MAX_FRAME_SAMPLES + i, content.height - 1 - j, LerpColor(GetColor(0x00BB0011), GetColor(0xEE0000FF), (float)j / content.height));
        }
    }
    const char* fps = TextFormat("%d FPS", GetFPS());
    DebugDrawText(content.width - MeasureTextEx(fntLilLabels, fps, LIL_LABELS_FONT_SIZE, 1).x - 3, 2, fps);
    #undef MAX_FRAME_SAMPLES

    DrawDebug();
#endif
}

void ResizeWindowSnapped(void) {
    monitor = GetCurrentMonitor();
    targetRefresh = GetMonitorRefreshRate(monitor);
    SetTargetFPS(targetRefresh);
    float monitorWidth = GetMonitorWidth(monitor);
    float monitorHeight = GetMonitorHeight(monitor);

    float screenWidth = (float)GetScreenWidth();
    float screenHeight = (float)GetScreenHeight();
    float widthRatio = screenWidth / content.width;
    float heightRatio = screenHeight / content.height;
    
    float contentScale = fminf(widthRatio, heightRatio); // pick smallest between width ratio and height ratio
    float snappedScale = oldScreenWidth * oldScreenHeight < screenWidth * screenHeight ? ceilf(contentScale) : floorf(contentScale);

    if (screenWidth < monitorWidth && screenHeight < monitorHeight ) { SetWindowSize(content.width * snappedScale, content.height * snappedScale); }

    screenWidth  = (float)GetScreenWidth();
    screenHeight = (float)GetScreenHeight();
    widthRatio = screenWidth / content.width;
    heightRatio  = screenHeight / content.height;
    contentScale = fminf(widthRatio, heightRatio); // pick smallest between width ratio and height ratio

    content.x = HALF(content.width);
    content.y = HALF(content.height);

    scaledWidth  = content.width * contentScale;
    scaledHeight = content.height * contentScale;
    scaledOrigin = (Vector2) { HALF(scaledWidth), HALF(scaledHeight) };
    screenOrigin = (Vector2) { HALF(screenWidth), HALF(screenHeight) };

    oldScreenWidth  = GetScreenWidth();
    oldScreenHeight = GetScreenHeight();
}

#endif

