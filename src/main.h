#pragma once
#include <raylib.h>
#ifdef MAIN_IMPL
#include <reasings.h>
#define BATBOX_IMPL
#include "batbox.h"
#define BATANIM_IMPL
#include "batanim.h"
#define BATIO_IMPL
#include "batio.h"
#if defined(_DEBUG)
    #define TBDB_DEBUG_IMPL
    #include "tbdebug.h"
#endif
#endif
#if defined(PLATFORM_WEB)
    #include <emscripten/emscripten.h>
    #define GLSL_VERSION (100)
#else
    #define GLSL_VERSION (330)
#endif

//-----Globals-----//
#ifdef MVERSION
#define TITLE MTITLE        // Makefile definitions
#define VERSION MVERSION
#else
#define TITLE ("Template")  // Game title
#define VERSION ("2.2.2")   // Generated by makefile
#endif

#define NUM_SPRITES (512)

static bool showSplash = 1;
static int monitor = 0;
static int targetRefresh = 60;

static int initScale = 3;
static Rectangle content = {128, 128, 256, 256};
static float scaledWidth, scaledHeight;
static float oldScreenWidth, oldScreenHeight;
static Vector2 scaledOrigin, screenOrigin;

//-----Assets-----//
static RenderTexture2D rtxContent; // Pixel canvas
static RenderTexture2D rtxLightingTexture;
static RenderTexture2D rtxCombinedTexture;
static Texture2D texGrid;
static Texture2D texTestImage;
static Texture2D texPlane;
static Texture2D texSnowman;
static Texture2D texProps;
static Texture2D texSnowmanFaces;
static Texture2D texSky;
static Texture2D texLight0;
static Texture2D texWeapons;
static Shader shdWarp;
static Shader shdProp;
static Shader shdPropEm;
static Sound sfxPause;
static Font fntLilLabels;
#define LIL_LABELS_FONT_SIZE (7)

int LightmapUniformLoc;



// TODO: Baz set the color pool colors
static Color BulbColorPool[5] = {
    RED,
    GREEN, 
    YELLOW,
    BLUE,
    PINK
};

static Color BulbLightColorPool[5] = {
    RED,
    GREEN, 
    YELLOW,
    BLUE,
    PINK
};




//-----Definitions-----//
typedef struct State { // Global state, keeps track of time and mode
    int mode;
    int prevMode;
    double unpausedTime;
    double totalTime;
    double deltaTime;
    void (*UpdateFunc)(void);
    void (*DrawFunc)(void);
    bool isPaused;
    bool wasUnfocused;
} State;

enum Modes {
    MODE_SPLASH,
    MODE_GAME,
    MODE_PAUSED,
};

#ifdef MAIN_IMPL
State state;
#endif

//-----Functions-----//

 // Initializes window, target framerate, audio device, assets, splash screen
static void Init(void);
 // Runs once before update
static void Setup(void);
static void Update(void);
static void Draw(void);
static void Unload(void);
static void UpdateDrawFrame(void);

static void LoadAssets(void); 
static void UnloadAssets(void);

static void UpdateGame(void);
static void DrawGame(void);

static void PauseGame(void);
static void ResumeGame(void);
static void UpdatePaused(void);

static void ScaleWindowToContent(void);
static void DrawDebugInfo(void);

void SpawnProp(int id, float x, float y, bool emissive, Rectangle prop, Vector2 scale);
void SpawnSnowman(int id, float x, float y);
void ClearAllSprites(void);
void ClearSprite(int i);



#ifdef MAIN_IMPL
#include <raymath.h>

//-----Implementation-----//
void LoadAssets(void) { // Loads textures, shaders, audio, fonts, etc.
    rtxContent = LoadRenderTexture(content.width, content.height);
    rtxLightingTexture = LoadRenderTexture(256*4, 256*4);
    rtxCombinedTexture = LoadRenderTexture(256*4, 256*4);

    texTestImage = LoadTexture("assets/textures/test.png");
    texGrid = LoadTexture("assets/textures/grid.png");                              // Load a texture
    texPlane = LoadTexture("assets/textures/snow.png");
    texSnowman = LoadTexture("assets/textures/snowman.png");
    texSnowmanFaces = LoadTexture("assets/textures/snowman_faces.png");
    GenTextureMipmaps(&texPlane);
    texSky  = LoadTexture("assets/textures/skybox.png");
    texLight0 = LoadTexture("assets/textures/light0.png");
    SetTextureFilter(texLight0, TEXTURE_FILTER_BILINEAR);

    SetTextureWrap(rtxLightingTexture.texture, TEXTURE_WRAP_CLAMP);

    texWeapons = LoadTexture("assets/textures/weapons.png");
    texProps = LoadTexture("assets/textures/props.png");

    shdWarp = LoadShader(0, TextFormat("assets/shaders/warp%d.fs", GLSL_VERSION));  // Load a shader based on GLSL version
    shdProp = LoadShader("assets/shaders/prop.vs", "assets/shaders/prop.fs");
    shdPropEm = LoadShader(0, "assets/shaders/prop.fs");
    LightmapUniformLoc = GetShaderLocation(shdProp, "texLightmap");

    sfxPause = LoadSound("assets/audio/pause.ogg");                                 // Load a sound
    fntLilLabels = LoadFontEx("assets/fonts/lil_labels.ttf", 7, 0, 0);              // Load a font
    SetTextureFilter(GetFontDefault().texture, TEXTURE_FILTER_POINT);               // Ensure default font is pixelated
}

void UnloadAssets(void) {
    UnloadRenderTexture(rtxContent);
}


enum GSType {
    GST_Prop,
    GST_Snowman,
    GST_EnemyBullet,
    GST_PlayerBullet
};

enum BulletType {
// player
    BTP_Melee,
    BTP_Bulb,
    BTP_Bulb2,
// enemy 
    BTE_Snowball,
    BTE_Explosion,
};

enum AI_Attack {
    AIA_snowball,
    AIA_snowball2,
    AIA_bomb,
};


enum AI_State {
    AIS_Wander,
    AIS_Hunt,
    AIS_Run,
    AIS_Goto,
};

typedef struct Light {
  float radius;
  Color color;  
} Light;

typedef struct AI {
    bool isAttacking;
    float attackCooldown;
    float stateCooldown;
    float extraCooldown;
    int state;
    int nextstate;
    Vector2 velocity;

//-
    float desiredDistance;
    float escapeDistance;
    float engageDistance;
    float wanderSpeed;
    float huntSpeed;
    float runSpeed;
    int attackType;
    bool friendly;
} AI;

typedef struct GameSprite {
    bool enabled;
    int type;
    bool baseIsEmissive;
    int emissiveFrames;
    float emissiveFrameSpeed;
    float x, y;
    float hover;
    float angle;
    uint16_t animID;
    bool isAnimated;
    Rectangle rect;
    Vector2 scale;
    Color c;
    bool hasLight;
    Light light;
    float size;
    int health;
    bool hasAI;
    AI ai;
} GameSprite;

#define Prop_Tree (Rectangle){0,0,64,64}
#define Prop_Bulb (Rectangle){64,0,64,64}

GameSprite sprites[NUM_SPRITES] = { 0
    //{.type = GST_Snowman, .x = 0, .y = 10, .c = RED, .enabled = true, .rect = {0,0,16,16}, .hasLight = true, .light = {.radius = 1.2, .color = RED}},
    //{.type = GST_Snowman, .x = 50, .y = 32, .c = PURPLE, .enabled = true, .rect = {0,0,16,16}, .hasLight = true, .light = {.radius = 1, .color = PINK}},
    //{.type = GST_Prop, .x = -40, .y = -14, .c = WHITE, .enabled = true, .rect = Prop_Tree, .scale = {4,4}},
    //{.type = GST_Prop, .x = -35, .y = -10, .c = WHITE, .enabled = true, .rect = Prop_Tree, .scale = {4,4}},
};

static Vector2 playerPos = {0,0};
static Vector2 playerVel = {0,0};
static float rotationY = 0;
static float rotationX = 0;
static float skyScroll = 0;
bool isMouseLocked = false;
Vector2 mouseDelta = {0,0};
Vector2 mouseSensitivity = {40.1,20.05};
Vector2 moveSpeed = {10,10};

bool once = false;

void UpdateGame(void) {
    if (!once) {
        
        for (size_t i = 0; i < 128; i++)
        {
            SpawnProp(i, GetRandomValue(-128,128), GetRandomValue(-128,128), false, Prop_Tree, (Vector2){GetRandomValue(3,4),4} );
            if (GetRandomValue(0,5) == 0) {
                sprites[i].emissiveFrames = 2;
                sprites[i].emissiveFrameSpeed = 2;
            }
        }

        for (size_t i = 0; i < 10; i++)
        {
            SpawnSnowman(127 + i, GetRandomValue(-80, 80),GetRandomValue(-80, 80));
        }
        
        for (size_t i = 0; i < 10; i++)
        {
            SpawnProp(127 + 10 + i, GetRandomValue(-128,128), GetRandomValue(-128,128), true, Prop_Bulb, (Vector2){3,3} );
            sprites[127 + 10 + i].hasLight = true;
            int colorV = GetRandomValue(0,4);
            sprites[127 + 10 + i].c = BulbColorPool[colorV],
            sprites[127 + 10 + i].light = (Light){.color = BulbLightColorPool[colorV], .radius = 1.2f};
        }

        sprites[40].hasAI = true;
        sprites[40].emissiveFrames = 0;
        sprites[40].ai = (AI){
            .friendly = true, 
            .desiredDistance = 4, 
            .escapeDistance = 20, 
            .engageDistance = 9,
            .wanderSpeed = 4,
        };
        
        once = true;
    }

    if (IsInputP(INPUT_START)) { PauseGame(); }

    if (!isMouseLocked) {
        if (IsMouseButtonDown(MOUSE_BUTTON_LEFT)) {
            isMouseLocked = true;
            DisableCursor();
        }
    } else {
        mouseDelta = GetMouseDelta();
        // SetMousePosition(content.x,content.y);

        if (IsKeyPressed(KEY_ESCAPE)) {
            isMouseLocked = false;
            mouseDelta = (Vector2) {0,0};
            EnableCursor();
        }
    }


    for (size_t i = 0; i < NUM_SPRITES; i++)
    {
        if (sprites[i].enabled == false) {continue;}

        if (sprites[i].hasAI == true) {

            AI* ai = &sprites[i].ai;
            if (ai->friendly) {ai->state = AIS_Wander;}

            switch (sprites[i].ai.state)
            {

            case AIS_Wander: {
                if (ai->extraCooldown <= 0) {
                    ai->extraCooldown = GetRandomValue(1,5) + ai->friendly ? 2.3f : 0;

                    sprites[i].angle = GetRandomValue(0,360);
                    ai->velocity = Vector2Scale( Vector2Rotate((Vector2){0,1}, sprites[i].angle * DEG2RAD), 7 );
                }
                ai->extraCooldown -= state.deltaTime;

                break;
            }

            case AIS_Run: {

                break;
            }

            case AIS_Hunt: {

                break;
            }

            case AIS_Goto: {
                if (ai->stateCooldown <= 0) {
                    ai->state = ai->nextstate;
                } else {
                    ai->stateCooldown -= state.deltaTime;
                }
                break;
            }

            default:
                TraceLog(LOG_ERROR, "Sprite with ID [%d] has unknown AI state: [%d]. This sprite will be deleted.", i, sprites[i].ai.state);
                sprites[i] = (GameSprite){0};
                break;
            }

            sprites[i].x += sprites[i].ai.velocity.x * state.deltaTime;
            sprites[i].y += sprites[i].ai.velocity.y * state.deltaTime;
            
            sprites[i].x = Clamp(sprites[i].x, -100, 100);
            sprites[i].y = Clamp(sprites[i].y, -100, 100);

        }

    }
    


    rotationY -= mouseDelta.x * mouseSensitivity.x * state.deltaTime;
    if (rotationY > 360) rotationY -= 360;
    if (rotationY < 0) rotationY += 360;
    rotationX += mouseDelta.y * mouseSensitivity.y * state.deltaTime;
    rotationX = Clamp(rotationX,-80,70);

    skyScroll -= mouseDelta.x * mouseSensitivity.x * state.deltaTime;
    if (skyScroll > 360*2) skyScroll -= 360*2;
    if (skyScroll < 0) skyScroll += 360*2;

    int horizontal = (( (input & INPUT_RIGHT) > 0) - ((input & INPUT_LEFT) > 0 ));
    int vertical   = (( (input & INPUT_DOWN) > 0) - ((input & INPUT_UP) > 0 ));
    
    Vector2 playerInput = Vector2Normalize((Vector2){-horizontal, -vertical});

    playerVel =  Vector2Lerp( playerVel, (Vector2){playerInput.x * moveSpeed.x, playerInput.y * moveSpeed.y}, state.deltaTime * 15);

    playerPos = Vector2Add(Vector2Rotate((Vector2){playerVel.x * state.deltaTime, playerVel.y * state.deltaTime }, (-rotationY) * DEG2RAD),playerPos); 

    playerPos = Vector2Clamp(playerPos, (Vector2){-100,-100}, (Vector2){100,100});
    
}

void ClearSprite(int id) {
    sprites[id] = (GameSprite){0};
}

void ClearAllSprites(void) {
    for (size_t i = 0; i < NUM_SPRITES; i++)
    {
        sprites[i] = (GameSprite){0};
    }
}

int FindFreeID(void) {
    for (size_t i = 0; i < NUM_SPRITES; i++)
    {
        if (!sprites[i].enabled) {return i;}
    } 
    return -1;   
}

void SpawnProp(int id, float x, float y, bool emissive, Rectangle prop, Vector2 scale) {
    if (!sprites[id].enabled) {
        sprites[id] = (GameSprite){
            .enabled = true,
            .type = GST_Prop, 
            .x = x, 
            .y = y, 
            .c = WHITE, 
            .rect = prop, 
            .scale = scale,
            .baseIsEmissive = emissive,
            .emissiveFrames = emissive ? 1 : 0,
            .emissiveFrameSpeed = emissive ? 1 : 0,
            .size = 2
        };
    }
}

void SpawnSnowman(int id, float x, float y) {
    if (!sprites[id].enabled) {
        
        sprites[id] = (GameSprite){
            .enabled = true,
            .type = GST_Snowman, 
            .x = x, 
            .y = y, 
            .c = RED,
            .size = 1,
            .hasLight = true,
            //.light = {.radius = 0.4, .color = RED},
            .hasAI = true,
            .ai = {
                .friendly =false,
                .wanderSpeed = 7,
                .runSpeed = 8,
                .huntSpeed = 8,
                .desiredDistance = 4, 
                .escapeDistance = 20, 
                .engageDistance = 9, 
                .attackType = AIA_snowball
            },
        };
        
        return;
    }
}

void DrawSnowman(Camera cam, int spriteIndex) {
    int i = spriteIndex;

    Rectangle r0 = (Rectangle){0,48,64,48};
    Rectangle r1 = (Rectangle){48,0,64,48};
    Rectangle r2 = (Rectangle){0,0,48,48};
    
    //Rectangle fr0 = (Rectangle){0,0,48,48};

    Rectangle faces[4] = {
        (Rectangle){0,0,48,48},
        (Rectangle){48,0,48,48},
        (Rectangle){48*2,0,1,1},
        (Rectangle){48*3,0,48,48},
    };

    float bob0 = 0.03 * sin(state.unpausedTime * 4);
    float bob1 = 0.02 * sin(state.unpausedTime * 3.8);
    float bob2 = 0.01 * sin(state.unpausedTime * 3.5);


    DrawBillboardRec(cam, texSnowman, r0, (Vector3){ sprites[i].x, 0.5 + bob0, sprites[i].y }, (Vector2){1,1}, WHITE);

    Vector2 pos = Vector2MoveTowards((Vector2){sprites[i].x, sprites[i].y}, playerPos, 0.1f);

    DrawBillboardRec(cam, texSnowman, r1, (Vector3){ pos.x, 1.1 + bob0 + bob1, pos.y }, (Vector2){1,1}, WHITE);

    pos = Vector2MoveTowards(pos, playerPos, 0.1f);
    
    DrawBillboardRec(cam, texSnowman, r2, (Vector3){ pos.x, 1.6 + bob0 + bob1 + bob2, pos.y }, (Vector2){1,1}, WHITE);

    pos = Vector2MoveTowards(pos, playerPos, 0.1f);
    
    DrawBillboardRec(cam, texSnowmanFaces, faces[ (int)state.unpausedTime % 4 ], (Vector3){ pos.x, 1.6 + bob0 + bob1 + bob2, pos.y }, (Vector2){1,1}, WHITE);


}



Vector2 MapCoordToLightCoord(float x, float y) {
    return (Vector2){(x+128) * 4, (y+128) * 4};
}


void RenderLightingTexture(void) {
    BeginTextureMode(rtxLightingTexture); {

        DrawRectangle(0,0,256*4,256*4, GetColor(0x01021aFF));
        Vector2 pl = MapCoordToLightCoord(playerPos.x,playerPos.y);

        DrawTextureEx(texLight0, Vector2Subtract((Vector2){pl.x, pl.y} , (Vector2){16*20,16*20}), 0, 20, GetColor(0x22223222));

        float scale = 5.3;
        float colorscale = scale * 1.2;
        DrawTextureEx(texLight0, Vector2Subtract((Vector2){pl.x, pl.y} , (Vector2){16*scale,16*scale}), 0, scale, GetColor(0x99999944));
        
        for (size_t i = 0; i < NUM_SPRITES; i++)
        {
            if (!sprites[i].enabled || !sprites[i].hasLight) continue;

            Vector2 p = MapCoordToLightCoord(sprites[i].x, sprites[i].y);
            float s   = sprites[i].light.radius;

            DrawTextureEx(texLight0, Vector2Subtract((Vector2){p.x, p.y} , (Vector2){16*s,16*s}), 0, s, GetColor(0xAAAAAA77));
        }
        

        BeginBlendMode(BLEND_ADDITIVE);
        for (size_t i = 0; i < NUM_SPRITES; i++)
        {
            if (!sprites[i].enabled || !sprites[i].hasLight) continue;

            Vector2 p = MapCoordToLightCoord(sprites[i].x, sprites[i].y);
            float s   = sprites[i].light.radius * 1.2;

            DrawTextureEx(texLight0, Vector2Subtract((Vector2){p.x, p.y} , (Vector2){16*s,16*s}), 0, s, sprites[i].light.color);
        }
        DrawTextureEx(texLight0, Vector2Subtract((Vector2){pl.x, pl.y} , (Vector2){16*colorscale,16*colorscale}), 0, colorscale, GetColor(0xAAAAAAAA) );
        EndBlendMode();
        
        //DrawTextureEx(texTestImage, (Vector2){0,0}, 0, 4, WHITE);

        EndTextureMode();
    }

    BeginTextureMode(rtxCombinedTexture); {

        DrawTextureTiled(texPlane, (Rectangle) {0, 0, 512, 512}, (Rectangle) {0, 0, 1024, 1024}, (Vector2) {0, 0}, 0, 1, WHITE);

        BeginBlendMode(BLEND_MULTIPLIED);
        DrawTextureQuad(rtxLightingTexture.texture, (Vector2){1,-1}, (Vector2){0,0}, (Rectangle){0,0,256*4,256*4}, WHITE);
        EndBlendMode();

        EndTextureMode();
    } 


}

void RenderScene(void) {

    DrawTextureRec(texSky, (Rectangle) {0, 0, 360, 256},    (Vector2) {skyScroll, 0}, WHITE);
    DrawTextureRec(texSky, (Rectangle) {0, 0, 360, 256},    (Vector2) {skyScroll - 360, 0}, WHITE);
    DrawTextureRec(texSky, (Rectangle) {0, 256, 360, 256},  (Vector2) {skyScroll - 360 * 2, 0}, WHITE);


    Camera cam;
    cam.projection = CAMERA_PERSPECTIVE;
    cam.fovy = 90;

    cam.up = (Vector3){0,1,0};

    float bobbing = sin(state.unpausedTime * 12) * Vector2Length( (Vector2) {playerVel.x / moveSpeed.x, playerVel.y / moveSpeed.y} ) * 0.06;

    cam.position = (Vector3){playerPos.x, 1 +  bobbing,playerPos.y};


    Quaternion Q = QuaternionMultiply(
        QuaternionFromAxisAngle((Vector3){0,1,0}, rotationY * DEG2RAD),
        QuaternionFromAxisAngle((Vector3){1,0,0}, rotationX * DEG2RAD)
    );

    cam.target = Vector3Add(
        cam.position,
        Vector3RotateByQuaternion((Vector3){0,0,1}, Q)
    );

    BeginMode3D(cam);


    DrawCubeTexture(rtxCombinedTexture.texture, (Vector3){0,0,0}, 256, 0.1, 256, WHITE);

    SetShaderValueTexture(shdProp, LightmapUniformLoc, rtxLightingTexture.texture);
    BeginShaderMode(shdProp);

    for (size_t i = 0; i < NUM_SPRITES; i++)
    {
        if (sprites[i].enabled == false) {continue;}
        
        switch (sprites[i].type)
        {

        case GST_Prop: {
            if (sprites[i].baseIsEmissive) {break;}
            DrawBillboardRec(cam, texProps, sprites[i].rect, (Vector3){ sprites[i].x, sprites[i].scale.y / 2, sprites[i].y }, sprites[i].scale, sprites[i].c);
            break;
        }
        
        case GST_Snowman: {
            DrawSnowman(cam, i);
            break;
        }
            
        default:
            break;
        }
        
    }

    EndShaderMode();

    // draw emissive 
    BeginShaderMode(shdPropEm);

    for (size_t i = 0; i < NUM_SPRITES; i++)
    {
        if (sprites[i].enabled == false) {continue;}
        
        
        Vector2 pos = (Vector2){sprites[i].x, sprites[i].y};
        if (sprites[i].baseIsEmissive) {
            DrawBillboardRec(cam, texProps, 
                (Rectangle) {sprites[i].rect.x, sprites[i].rect.y, sprites[i].rect.width, sprites[i].rect.height }, 
                (Vector3){ pos.x, sprites[i].scale.y / 2, pos.y }, sprites[i].scale, sprites[i].c
            );
        }
        
        if (sprites[i].emissiveFrames > 0) {

            if (Vector2Distance(pos, playerPos) > 50) {continue;}

            pos = Vector2MoveTowards(pos, playerPos, 0.025f);
            int frame = 1 + (int)(state.unpausedTime * sprites[i].emissiveFrameSpeed) % sprites[i].emissiveFrames;
            DrawBillboardRec(cam, texProps, 
                (Rectangle) {sprites[i].rect.x, sprites[i].rect.y + (64 * frame) , sprites[i].rect.width, sprites[i].rect.height }, 
                (Vector3){ pos.x, sprites[i].scale.y / 2, pos.y }, sprites[i].scale, WHITE
            );
        }
    }

    EndShaderMode();    

    EndMode3D();

    

}

void RenderMapOverlay(void) {
    float ox = 128;
    float oy = 128;


    //DrawTextureEx(rtxLightingTexture.texture, (Vector2){0,0}, 0, 0.25, WHITE);
    if (IsKeyDown(KEY_LEFT_SHIFT)) {
        DrawTextureQuad(rtxLightingTexture.texture, (Vector2){1,-1}, (Vector2){0,0}, (Rectangle){0,0,256,256}, WHITE);
    }

    DrawPixel(ox + playerPos.x,oy + playerPos.y, GREEN);
    Vector2 lookLine = Vector2Add(Vector2Rotate((Vector2){0, 8}, (-rotationY) * DEG2RAD), playerPos);
    DrawLine( ox + playerPos.x, oy + playerPos.y, ox + lookLine.x, oy + lookLine.y, GREEN);

    Vector2 lookLine1 = Vector2Add(Vector2Rotate((Vector2){0, 13}, (-rotationY-45) * DEG2RAD), playerPos);
    DrawLine( ox + playerPos.x, oy + playerPos.y, ox + lookLine1.x, oy + lookLine1.y, BLUE);
    Vector2 lookLine2 = Vector2Add(Vector2Rotate((Vector2){0, 13}, (-rotationY+45) * DEG2RAD), playerPos);
    DrawLine( ox + playerPos.x, oy + playerPos.y, ox + lookLine2.x, oy + lookLine2.y, BLUE);

    for (size_t i = 0; i < NUM_SPRITES; i++)
    {
        if (!sprites[i].enabled) continue;
        DrawPixel(ox + sprites[i].x, oy + sprites[i].y, sprites[i].c);
    }


}


void DrawGame(void) {
    ClearBackground(RAYWHITE);

    //for (int j = 0; j < content.height / 16; j++) { for (int i = 0; i < content.width / 16; i++) DrawTexture(texGrid, i * 16, j * 16, Fade(LIGHTGRAY, 0.4)); }
    
    RenderScene();

    DrawTexture(texWeapons, 128 - texWeapons.width/2, 256 - texWeapons.height, WHITE);

    if (IsKeyDown(KEY_TAB)) {
        RenderMapOverlay();
    }

    DrawText(TextFormat("%s v%s", TITLE, VERSION), 3, 2, 10, DARKGRAY);

    static double fadeTimer = 0.4;
    if (fadeTimer > 0) { DrawRectangle(0, 0, content.width, content.height, Fade(BLACK, EaseQuadOut(fadeTimer, 0, 1, 0.4))); fadeTimer -= state.deltaTime; }
}

void PauseGame(void) {
    state.isPaused = true;
    state.prevMode = state.mode;
    state.mode = MODE_PAUSED;
    if (state.wasUnfocused) { return; }
    PlaySoundPitch(sfxPause, 1.0, false);
}

void ResumeGame(void) {
    state.isPaused = false;
    state.mode = state.prevMode;
    if (state.wasUnfocused) { return; }
    PlaySoundPitch(sfxPause, 1.1, false);
}

void UpdatePaused(void) {
    if (IsInputP(INPUT_START)) { ResumeGame(); }
}

void DrawPausedOverlay(void) {
    if (!state.isPaused) { return; }
    DrawRectangle(0, 0, content.width, content.height, Fade(BLACK, 0.5));
    if (state.wasUnfocused) { return; }
    DrawTextCentered("PAUSED", content.x, content.y, 10, 1, WHITE);
}

void DrawContent(void) {
    DrawTexturePro(rtxContent.texture,
    (Rectangle) {0, 0, content.width, -content.height},
    (Rectangle) {0, 0, content.width, content.height},
    (Vector2) {0, 0}, 0, WHITE);

    state.DrawFunc();

    DrawDebugInfo();
    
    DrawPausedOverlay();
}

void DrawDebugInfo(void) {
#if defined(_DEBUG)
    #define MAX_FRAME_SAMPLES (100)
    static float frameSamples[MAX_FRAME_SAMPLES] = {0};
    static float frameSampleTimer = 0;

    frameSampleTimer -= state.deltaTime;
    if (frameSampleTimer <= 0) {
        for (int i = MAX_FRAME_SAMPLES - 1; i > 0; i--) { frameSamples[i] = frameSamples[i-1]; }
        frameSamples[0] = GetFrameTime();
        frameSampleTimer = (1 / 60) * 10; 
    }
    for (int i = 0; i < MAX_FRAME_SAMPLES; i++) {
        float delayTime = frameSamples[i];
        for (int j = 0; j < delayTime * 50; j++) {
            DrawPixel(content.width - MAX_FRAME_SAMPLES + i, content.height - 1 - j, LerpColor(GetColor(0x00BB0011), GetColor(0xEE0000FF), (float)j / content.height));
        }
    }
    const char* fps = TextFormat("%d FPS", GetFPS());
    DebugDrawText(content.width - MeasureTextEx(fntLilLabels, fps, LIL_LABELS_FONT_SIZE, 1).x - 3, 2, fps);
    #undef MAX_FRAME_SAMPLES

    DrawDebug();
#endif
}

void ResizeWindowSnapped(void) {
    monitor = GetCurrentMonitor();
    targetRefresh = GetMonitorRefreshRate(monitor);
    SetTargetFPS(targetRefresh);
    float monitorWidth = GetMonitorWidth(monitor);
    float monitorHeight = GetMonitorHeight(monitor);

    float screenWidth = (float)GetScreenWidth();
    float screenHeight = (float)GetScreenHeight();
    float widthRatio = screenWidth / content.width;
    float heightRatio = screenHeight / content.height;
    
    float contentScale = fminf(widthRatio, heightRatio); // pick smallest between width ratio and height ratio
    float snappedScale = oldScreenWidth * oldScreenHeight < screenWidth * screenHeight ? ceilf(contentScale) : floorf(contentScale);

    if (screenWidth < monitorWidth && screenHeight < monitorHeight ) { SetWindowSize(content.width * snappedScale, content.height * snappedScale); }

    screenWidth  = (float)GetScreenWidth();
    screenHeight = (float)GetScreenHeight();
    widthRatio = screenWidth / content.width;
    heightRatio  = screenHeight / content.height;
    contentScale = fminf(widthRatio, heightRatio); // pick smallest between width ratio and height ratio

    content.x = HALF(content.width);
    content.y = HALF(content.height);

    scaledWidth  = content.width * contentScale;
    scaledHeight = content.height * contentScale;
    scaledOrigin = (Vector2) { HALF(scaledWidth), HALF(scaledHeight) };
    screenOrigin = (Vector2) { HALF(screenWidth), HALF(screenHeight) };

    oldScreenWidth  = GetScreenWidth();
    oldScreenHeight = GetScreenHeight();
}

#endif

